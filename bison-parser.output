Terminals which are not used

   OTHER


Grammar

    0 $accept: prog $end

    1 prog: /* empty */
    2     | header lista_decl lista_isntr final

    3 header: INTDECL MAIN LEFT_PAR RIGHT_PAR LEFT_BR

    4 lista_decl: decl SEMICOLON
    5           | decl SEMICOLON lista_decl

    6 decl: tip variabila

    7 tip: INTDECL
    8    | FLOATDECL

    9 variabila: ID
   10          | IDVECTOR

   11 lista_isntr: /* empty */
   12            | instr SEMICOLON lista_isntr

   13 instr: /* empty */
   14      | attr
   15      | inout
   16      | if_exp
   17      | while_exp

   18 attr: ID EQUALS exp

   19 exp: /* empty */
   20    | const
   21    | variabila
   22    | exp PLUS variabila
   23    | exp MINUS variabila
   24    | exp DIV variabila
   25    | exp MOD variabila
   26    | exp MUL variabila

   27 const: INTEGER
   28      | FLOAT

   29 inout: INOP INOPF variabila
   30      | OUTOP OUTOPF exp

   31 if_exp: IFSTMT LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

   32 while_exp: WHILESTMT LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

   33 condition: exp RELATION exp

   34 final: RETURN INTEGER SEMICOLON RIGHT_BR


Terminals, with rules where they appear

$end (0) 0
error (256)
OUTOPF (258) 30
INOPF (259) 29
RETURN (260) 34
MAIN (261) 3
LEFT_PAR (262) 3 31 32
RIGHT_PAR (263) 3 31 32
LEFT_BR (264) 3 31 32
RIGHT_BR (265) 31 32 34
PLUS (266) 22
MINUS (267) 23
DIV (268) 24
MUL (269) 26
MOD (270) 25
INOP (271) 29
OUTOP (272) 30
IFSTMT (273) 31
WHILESTMT (274) 32
INTDECL (275) 3 7
FLOATDECL (276) 8
EQUALS (277) 18
INTEGER (278) 27 34
FLOAT (279) 28
OTHER (280)
SEMICOLON (281) 4 5 12 34
ID (282) 9 18
IDVECTOR (283) 10
RELATION (284) 33


Nonterminals, with rules where they appear

$accept (30)
    on left: 0
prog (31)
    on left: 1 2, on right: 0
header (32)
    on left: 3, on right: 2
lista_decl (33)
    on left: 4 5, on right: 2 5
decl (34)
    on left: 6, on right: 4 5
tip (35)
    on left: 7 8, on right: 6
variabila (36)
    on left: 9 10, on right: 6 21 22 23 24 25 26 29
lista_isntr (37)
    on left: 11 12, on right: 2 12 31 32
instr (38)
    on left: 13 14 15 16 17, on right: 12
attr (39)
    on left: 18, on right: 14
exp (40)
    on left: 19 20 21 22 23 24 25 26, on right: 18 22 23 24 25 26 30
    33
const (41)
    on left: 27 28, on right: 20
inout (42)
    on left: 29 30, on right: 15
if_exp (43)
    on left: 31, on right: 16
while_exp (44)
    on left: 32, on right: 17
condition (45)
    on left: 33, on right: 31 32
final (46)
    on left: 34, on right: 2


state 0

    0 $accept: . prog $end

    INTDECL  shift, and go to state 1

    $default  reduce using rule 1 (prog)

    prog    go to state 2
    header  go to state 3


state 1

    3 header: INTDECL . MAIN LEFT_PAR RIGHT_PAR LEFT_BR

    MAIN  shift, and go to state 4


state 2

    0 $accept: prog . $end

    $end  shift, and go to state 5


state 3

    2 prog: header . lista_decl lista_isntr final

    INTDECL    shift, and go to state 6
    FLOATDECL  shift, and go to state 7

    lista_decl  go to state 8
    decl        go to state 9
    tip         go to state 10


state 4

    3 header: INTDECL MAIN . LEFT_PAR RIGHT_PAR LEFT_BR

    LEFT_PAR  shift, and go to state 11


state 5

    0 $accept: prog $end .

    $default  accept


state 6

    7 tip: INTDECL .

    $default  reduce using rule 7 (tip)


state 7

    8 tip: FLOATDECL .

    $default  reduce using rule 8 (tip)


state 8

    2 prog: header lista_decl . lista_isntr final

    INOP       shift, and go to state 12
    OUTOP      shift, and go to state 13
    IFSTMT     shift, and go to state 14
    WHILESTMT  shift, and go to state 15
    ID         shift, and go to state 16

    SEMICOLON  reduce using rule 13 (instr)
    $default   reduce using rule 11 (lista_isntr)

    lista_isntr  go to state 17
    instr        go to state 18
    attr         go to state 19
    inout        go to state 20
    if_exp       go to state 21
    while_exp    go to state 22


state 9

    4 lista_decl: decl . SEMICOLON
    5           | decl . SEMICOLON lista_decl

    SEMICOLON  shift, and go to state 23


state 10

    6 decl: tip . variabila

    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    variabila  go to state 26


state 11

    3 header: INTDECL MAIN LEFT_PAR . RIGHT_PAR LEFT_BR

    RIGHT_PAR  shift, and go to state 27


state 12

   29 inout: INOP . INOPF variabila

    INOPF  shift, and go to state 28


state 13

   30 inout: OUTOP . OUTOPF exp

    OUTOPF  shift, and go to state 29


state 14

   31 if_exp: IFSTMT . LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

    LEFT_PAR  shift, and go to state 30


state 15

   32 while_exp: WHILESTMT . LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

    LEFT_PAR  shift, and go to state 31


state 16

   18 attr: ID . EQUALS exp

    EQUALS  shift, and go to state 32


state 17

    2 prog: header lista_decl lista_isntr . final

    RETURN  shift, and go to state 33

    final  go to state 34


state 18

   12 lista_isntr: instr . SEMICOLON lista_isntr

    SEMICOLON  shift, and go to state 35


state 19

   14 instr: attr .

    $default  reduce using rule 14 (instr)


state 20

   15 instr: inout .

    $default  reduce using rule 15 (instr)


state 21

   16 instr: if_exp .

    $default  reduce using rule 16 (instr)


state 22

   17 instr: while_exp .

    $default  reduce using rule 17 (instr)


state 23

    4 lista_decl: decl SEMICOLON .
    5           | decl SEMICOLON . lista_decl

    INTDECL    shift, and go to state 6
    FLOATDECL  shift, and go to state 7

    $default  reduce using rule 4 (lista_decl)

    lista_decl  go to state 36
    decl        go to state 9
    tip         go to state 10


state 24

    9 variabila: ID .

    $default  reduce using rule 9 (variabila)


state 25

   10 variabila: IDVECTOR .

    $default  reduce using rule 10 (variabila)


state 26

    6 decl: tip variabila .

    $default  reduce using rule 6 (decl)


state 27

    3 header: INTDECL MAIN LEFT_PAR RIGHT_PAR . LEFT_BR

    LEFT_BR  shift, and go to state 37


state 28

   29 inout: INOP INOPF . variabila

    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    variabila  go to state 38


state 29

   30 inout: OUTOP OUTOPF . exp

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    $default  reduce using rule 19 (exp)

    variabila  go to state 41
    exp        go to state 42
    const      go to state 43


state 30

   31 if_exp: IFSTMT LEFT_PAR . condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    $default  reduce using rule 19 (exp)

    variabila  go to state 41
    exp        go to state 44
    const      go to state 43
    condition  go to state 45


state 31

   32 while_exp: WHILESTMT LEFT_PAR . condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    $default  reduce using rule 19 (exp)

    variabila  go to state 41
    exp        go to state 44
    const      go to state 43
    condition  go to state 46


state 32

   18 attr: ID EQUALS . exp

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    $default  reduce using rule 19 (exp)

    variabila  go to state 41
    exp        go to state 47
    const      go to state 43


state 33

   34 final: RETURN . INTEGER SEMICOLON RIGHT_BR

    INTEGER  shift, and go to state 48


state 34

    2 prog: header lista_decl lista_isntr final .

    $default  reduce using rule 2 (prog)


state 35

   12 lista_isntr: instr SEMICOLON . lista_isntr

    INOP       shift, and go to state 12
    OUTOP      shift, and go to state 13
    IFSTMT     shift, and go to state 14
    WHILESTMT  shift, and go to state 15
    ID         shift, and go to state 16

    SEMICOLON  reduce using rule 13 (instr)
    $default   reduce using rule 11 (lista_isntr)

    lista_isntr  go to state 49
    instr        go to state 18
    attr         go to state 19
    inout        go to state 20
    if_exp       go to state 21
    while_exp    go to state 22


state 36

    5 lista_decl: decl SEMICOLON lista_decl .

    $default  reduce using rule 5 (lista_decl)


state 37

    3 header: INTDECL MAIN LEFT_PAR RIGHT_PAR LEFT_BR .

    $default  reduce using rule 3 (header)


state 38

   29 inout: INOP INOPF variabila .

    $default  reduce using rule 29 (inout)


state 39

   27 const: INTEGER .

    $default  reduce using rule 27 (const)


state 40

   28 const: FLOAT .

    $default  reduce using rule 28 (const)


state 41

   21 exp: variabila .

    $default  reduce using rule 21 (exp)


state 42

   22 exp: exp . PLUS variabila
   23    | exp . MINUS variabila
   24    | exp . DIV variabila
   25    | exp . MOD variabila
   26    | exp . MUL variabila
   30 inout: OUTOP OUTOPF exp .

    PLUS   shift, and go to state 50
    MINUS  shift, and go to state 51
    DIV    shift, and go to state 52
    MUL    shift, and go to state 53
    MOD    shift, and go to state 54

    $default  reduce using rule 30 (inout)


state 43

   20 exp: const .

    $default  reduce using rule 20 (exp)


state 44

   22 exp: exp . PLUS variabila
   23    | exp . MINUS variabila
   24    | exp . DIV variabila
   25    | exp . MOD variabila
   26    | exp . MUL variabila
   33 condition: exp . RELATION exp

    PLUS      shift, and go to state 50
    MINUS     shift, and go to state 51
    DIV       shift, and go to state 52
    MUL       shift, and go to state 53
    MOD       shift, and go to state 54
    RELATION  shift, and go to state 55


state 45

   31 if_exp: IFSTMT LEFT_PAR condition . RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

    RIGHT_PAR  shift, and go to state 56


state 46

   32 while_exp: WHILESTMT LEFT_PAR condition . RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

    RIGHT_PAR  shift, and go to state 57


state 47

   18 attr: ID EQUALS exp .
   22 exp: exp . PLUS variabila
   23    | exp . MINUS variabila
   24    | exp . DIV variabila
   25    | exp . MOD variabila
   26    | exp . MUL variabila

    PLUS   shift, and go to state 50
    MINUS  shift, and go to state 51
    DIV    shift, and go to state 52
    MUL    shift, and go to state 53
    MOD    shift, and go to state 54

    $default  reduce using rule 18 (attr)


state 48

   34 final: RETURN INTEGER . SEMICOLON RIGHT_BR

    SEMICOLON  shift, and go to state 58


state 49

   12 lista_isntr: instr SEMICOLON lista_isntr .

    $default  reduce using rule 12 (lista_isntr)


state 50

   22 exp: exp PLUS . variabila

    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    variabila  go to state 59


state 51

   23 exp: exp MINUS . variabila

    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    variabila  go to state 60


state 52

   24 exp: exp DIV . variabila

    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    variabila  go to state 61


state 53

   26 exp: exp MUL . variabila

    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    variabila  go to state 62


state 54

   25 exp: exp MOD . variabila

    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    variabila  go to state 63


state 55

   33 condition: exp RELATION . exp

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    $default  reduce using rule 19 (exp)

    variabila  go to state 41
    exp        go to state 64
    const      go to state 43


state 56

   31 if_exp: IFSTMT LEFT_PAR condition RIGHT_PAR . LEFT_BR lista_isntr RIGHT_BR

    LEFT_BR  shift, and go to state 65


state 57

   32 while_exp: WHILESTMT LEFT_PAR condition RIGHT_PAR . LEFT_BR lista_isntr RIGHT_BR

    LEFT_BR  shift, and go to state 66


state 58

   34 final: RETURN INTEGER SEMICOLON . RIGHT_BR

    RIGHT_BR  shift, and go to state 67


state 59

   22 exp: exp PLUS variabila .

    $default  reduce using rule 22 (exp)


state 60

   23 exp: exp MINUS variabila .

    $default  reduce using rule 23 (exp)


state 61

   24 exp: exp DIV variabila .

    $default  reduce using rule 24 (exp)


state 62

   26 exp: exp MUL variabila .

    $default  reduce using rule 26 (exp)


state 63

   25 exp: exp MOD variabila .

    $default  reduce using rule 25 (exp)


state 64

   22 exp: exp . PLUS variabila
   23    | exp . MINUS variabila
   24    | exp . DIV variabila
   25    | exp . MOD variabila
   26    | exp . MUL variabila
   33 condition: exp RELATION exp .

    PLUS   shift, and go to state 50
    MINUS  shift, and go to state 51
    DIV    shift, and go to state 52
    MUL    shift, and go to state 53
    MOD    shift, and go to state 54

    $default  reduce using rule 33 (condition)


state 65

   31 if_exp: IFSTMT LEFT_PAR condition RIGHT_PAR LEFT_BR . lista_isntr RIGHT_BR

    INOP       shift, and go to state 12
    OUTOP      shift, and go to state 13
    IFSTMT     shift, and go to state 14
    WHILESTMT  shift, and go to state 15
    ID         shift, and go to state 16

    SEMICOLON  reduce using rule 13 (instr)
    $default   reduce using rule 11 (lista_isntr)

    lista_isntr  go to state 68
    instr        go to state 18
    attr         go to state 19
    inout        go to state 20
    if_exp       go to state 21
    while_exp    go to state 22


state 66

   32 while_exp: WHILESTMT LEFT_PAR condition RIGHT_PAR LEFT_BR . lista_isntr RIGHT_BR

    INOP       shift, and go to state 12
    OUTOP      shift, and go to state 13
    IFSTMT     shift, and go to state 14
    WHILESTMT  shift, and go to state 15
    ID         shift, and go to state 16

    SEMICOLON  reduce using rule 13 (instr)
    $default   reduce using rule 11 (lista_isntr)

    lista_isntr  go to state 69
    instr        go to state 18
    attr         go to state 19
    inout        go to state 20
    if_exp       go to state 21
    while_exp    go to state 22


state 67

   34 final: RETURN INTEGER SEMICOLON RIGHT_BR .

    $default  reduce using rule 34 (final)


state 68

   31 if_exp: IFSTMT LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr . RIGHT_BR

    RIGHT_BR  shift, and go to state 70


state 69

   32 while_exp: WHILESTMT LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr . RIGHT_BR

    RIGHT_BR  shift, and go to state 71


state 70

   31 if_exp: IFSTMT LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR .

    $default  reduce using rule 31 (if_exp)


state 71

   32 while_exp: WHILESTMT LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR .

    $default  reduce using rule 32 (while_exp)
