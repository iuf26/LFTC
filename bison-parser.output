Terminals which are not used

   OTHER


Grammar

    0 $accept: prog $end

    1 prog: /* empty */
    2     | header lista_decl lista_isntr final

    3 header: INTDECL MAIN LEFT_PAR RIGHT_PAR LEFT_BR

    4 lista_decl: decl SEMICOLON
    5           | decl SEMICOLON lista_decl

    6 decl: tip variabila

    7 tip: INTDECL
    8    | FLOATDECL

    9 lista_isntr: /* empty */
   10            | instr SEMICOLON lista_isntr

   11 instr: /* empty */
   12      | attr
   13      | inout
   14      | if_exp
   15      | while_exp

   16 attr: ID EQUALS exp

   17 const: INTEGER
   18      | FLOAT

   19 variabila: ID
   20          | IDVECTOR

   21 exp: /* empty */
   22    | exp MINUS const
   23    | exp PLUS const
   24    | exp DIV const
   25    | exp MUL const
   26    | const
   27    | variabila
   28    | exp PLUS variabila
   29    | exp MINUS variabila
   30    | exp DIV variabila
   31    | exp MOD variabila
   32    | exp MUL variabila

   33 inout: INOP INOPF variabila
   34      | OUTOP OUTOPF exp

   35 if_exp: IFSTMT LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

   36 while_exp: WHILESTMT LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

   37 condition: exp RELATION exp

   38 final: RETURN INTEGER SEMICOLON RIGHT_BR


Terminals, with rules where they appear

$end (0) 0
error (256)
OUTOPF (258) 34
INOPF (259) 33
RETURN (260) 38
MAIN (261) 3
LEFT_PAR (262) 3 35 36
RIGHT_PAR (263) 3 35 36
LEFT_BR (264) 3 35 36
RIGHT_BR (265) 35 36 38
PLUS (266) 23 28
MINUS (267) 22 29
DIV (268) 24 30
MUL (269) 25 32
MOD (270) 31
INOP (271) 33
OUTOP (272) 34
IFSTMT (273) 35
WHILESTMT (274) 36
INTDECL (275) 3 7
FLOATDECL (276) 8
EQUALS (277) 16
INTEGER (278) 17 38
FLOAT (279) 18
OTHER (280)
SEMICOLON (281) 4 5 10 38
ID (282) 16 19
IDVECTOR (283) 20
RELATION (284) 37


Nonterminals, with rules where they appear

$accept (30)
    on left: 0
prog (31)
    on left: 1 2, on right: 0
header (32)
    on left: 3, on right: 2
lista_decl (33)
    on left: 4 5, on right: 2 5
decl (34)
    on left: 6, on right: 4 5
tip (35)
    on left: 7 8, on right: 6
lista_isntr (36)
    on left: 9 10, on right: 2 10 35 36
instr (37)
    on left: 11 12 13 14 15, on right: 10
attr (38)
    on left: 16, on right: 12
const (39)
    on left: 17 18, on right: 22 23 24 25 26
variabila (40)
    on left: 19 20, on right: 6 27 28 29 30 31 32 33
exp (41)
    on left: 21 22 23 24 25 26 27 28 29 30 31 32, on right: 16 22 23
    24 25 28 29 30 31 32 34 37
inout (42)
    on left: 33 34, on right: 13
if_exp (43)
    on left: 35, on right: 14
while_exp (44)
    on left: 36, on right: 15
condition (45)
    on left: 37, on right: 35 36
final (46)
    on left: 38, on right: 2


state 0

    0 $accept: . prog $end

    INTDECL  shift, and go to state 1

    $default  reduce using rule 1 (prog)

    prog    go to state 2
    header  go to state 3


state 1

    3 header: INTDECL . MAIN LEFT_PAR RIGHT_PAR LEFT_BR

    MAIN  shift, and go to state 4


state 2

    0 $accept: prog . $end

    $end  shift, and go to state 5


state 3

    2 prog: header . lista_decl lista_isntr final

    INTDECL    shift, and go to state 6
    FLOATDECL  shift, and go to state 7

    lista_decl  go to state 8
    decl        go to state 9
    tip         go to state 10


state 4

    3 header: INTDECL MAIN . LEFT_PAR RIGHT_PAR LEFT_BR

    LEFT_PAR  shift, and go to state 11


state 5

    0 $accept: prog $end .

    $default  accept


state 6

    7 tip: INTDECL .

    $default  reduce using rule 7 (tip)


state 7

    8 tip: FLOATDECL .

    $default  reduce using rule 8 (tip)


state 8

    2 prog: header lista_decl . lista_isntr final

    INOP       shift, and go to state 12
    OUTOP      shift, and go to state 13
    IFSTMT     shift, and go to state 14
    WHILESTMT  shift, and go to state 15
    ID         shift, and go to state 16

    SEMICOLON  reduce using rule 11 (instr)
    $default   reduce using rule 9 (lista_isntr)

    lista_isntr  go to state 17
    instr        go to state 18
    attr         go to state 19
    inout        go to state 20
    if_exp       go to state 21
    while_exp    go to state 22


state 9

    4 lista_decl: decl . SEMICOLON
    5           | decl . SEMICOLON lista_decl

    SEMICOLON  shift, and go to state 23


state 10

    6 decl: tip . variabila

    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    variabila  go to state 26


state 11

    3 header: INTDECL MAIN LEFT_PAR . RIGHT_PAR LEFT_BR

    RIGHT_PAR  shift, and go to state 27


state 12

   33 inout: INOP . INOPF variabila

    INOPF  shift, and go to state 28


state 13

   34 inout: OUTOP . OUTOPF exp

    OUTOPF  shift, and go to state 29


state 14

   35 if_exp: IFSTMT . LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

    LEFT_PAR  shift, and go to state 30


state 15

   36 while_exp: WHILESTMT . LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

    LEFT_PAR  shift, and go to state 31


state 16

   16 attr: ID . EQUALS exp

    EQUALS  shift, and go to state 32


state 17

    2 prog: header lista_decl lista_isntr . final

    RETURN  shift, and go to state 33

    final  go to state 34


state 18

   10 lista_isntr: instr . SEMICOLON lista_isntr

    SEMICOLON  shift, and go to state 35


state 19

   12 instr: attr .

    $default  reduce using rule 12 (instr)


state 20

   13 instr: inout .

    $default  reduce using rule 13 (instr)


state 21

   14 instr: if_exp .

    $default  reduce using rule 14 (instr)


state 22

   15 instr: while_exp .

    $default  reduce using rule 15 (instr)


state 23

    4 lista_decl: decl SEMICOLON .
    5           | decl SEMICOLON . lista_decl

    INTDECL    shift, and go to state 6
    FLOATDECL  shift, and go to state 7

    $default  reduce using rule 4 (lista_decl)

    lista_decl  go to state 36
    decl        go to state 9
    tip         go to state 10


state 24

   19 variabila: ID .

    $default  reduce using rule 19 (variabila)


state 25

   20 variabila: IDVECTOR .

    $default  reduce using rule 20 (variabila)


state 26

    6 decl: tip variabila .

    $default  reduce using rule 6 (decl)


state 27

    3 header: INTDECL MAIN LEFT_PAR RIGHT_PAR . LEFT_BR

    LEFT_BR  shift, and go to state 37


state 28

   33 inout: INOP INOPF . variabila

    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    variabila  go to state 38


state 29

   34 inout: OUTOP OUTOPF . exp

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    $default  reduce using rule 21 (exp)

    const      go to state 41
    variabila  go to state 42
    exp        go to state 43


state 30

   35 if_exp: IFSTMT LEFT_PAR . condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    $default  reduce using rule 21 (exp)

    const      go to state 41
    variabila  go to state 42
    exp        go to state 44
    condition  go to state 45


state 31

   36 while_exp: WHILESTMT LEFT_PAR . condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    $default  reduce using rule 21 (exp)

    const      go to state 41
    variabila  go to state 42
    exp        go to state 44
    condition  go to state 46


state 32

   16 attr: ID EQUALS . exp

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    $default  reduce using rule 21 (exp)

    const      go to state 41
    variabila  go to state 42
    exp        go to state 47


state 33

   38 final: RETURN . INTEGER SEMICOLON RIGHT_BR

    INTEGER  shift, and go to state 48


state 34

    2 prog: header lista_decl lista_isntr final .

    $default  reduce using rule 2 (prog)


state 35

   10 lista_isntr: instr SEMICOLON . lista_isntr

    INOP       shift, and go to state 12
    OUTOP      shift, and go to state 13
    IFSTMT     shift, and go to state 14
    WHILESTMT  shift, and go to state 15
    ID         shift, and go to state 16

    SEMICOLON  reduce using rule 11 (instr)
    $default   reduce using rule 9 (lista_isntr)

    lista_isntr  go to state 49
    instr        go to state 18
    attr         go to state 19
    inout        go to state 20
    if_exp       go to state 21
    while_exp    go to state 22


state 36

    5 lista_decl: decl SEMICOLON lista_decl .

    $default  reduce using rule 5 (lista_decl)


state 37

    3 header: INTDECL MAIN LEFT_PAR RIGHT_PAR LEFT_BR .

    $default  reduce using rule 3 (header)


state 38

   33 inout: INOP INOPF variabila .

    $default  reduce using rule 33 (inout)


state 39

   17 const: INTEGER .

    $default  reduce using rule 17 (const)


state 40

   18 const: FLOAT .

    $default  reduce using rule 18 (const)


state 41

   26 exp: const .

    $default  reduce using rule 26 (exp)


state 42

   27 exp: variabila .

    $default  reduce using rule 27 (exp)


state 43

   22 exp: exp . MINUS const
   23    | exp . PLUS const
   24    | exp . DIV const
   25    | exp . MUL const
   28    | exp . PLUS variabila
   29    | exp . MINUS variabila
   30    | exp . DIV variabila
   31    | exp . MOD variabila
   32    | exp . MUL variabila
   34 inout: OUTOP OUTOPF exp .

    PLUS   shift, and go to state 50
    MINUS  shift, and go to state 51
    DIV    shift, and go to state 52
    MUL    shift, and go to state 53
    MOD    shift, and go to state 54

    $default  reduce using rule 34 (inout)


state 44

   22 exp: exp . MINUS const
   23    | exp . PLUS const
   24    | exp . DIV const
   25    | exp . MUL const
   28    | exp . PLUS variabila
   29    | exp . MINUS variabila
   30    | exp . DIV variabila
   31    | exp . MOD variabila
   32    | exp . MUL variabila
   37 condition: exp . RELATION exp

    PLUS      shift, and go to state 50
    MINUS     shift, and go to state 51
    DIV       shift, and go to state 52
    MUL       shift, and go to state 53
    MOD       shift, and go to state 54
    RELATION  shift, and go to state 55


state 45

   35 if_exp: IFSTMT LEFT_PAR condition . RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

    RIGHT_PAR  shift, and go to state 56


state 46

   36 while_exp: WHILESTMT LEFT_PAR condition . RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR

    RIGHT_PAR  shift, and go to state 57


state 47

   16 attr: ID EQUALS exp .
   22 exp: exp . MINUS const
   23    | exp . PLUS const
   24    | exp . DIV const
   25    | exp . MUL const
   28    | exp . PLUS variabila
   29    | exp . MINUS variabila
   30    | exp . DIV variabila
   31    | exp . MOD variabila
   32    | exp . MUL variabila

    PLUS   shift, and go to state 50
    MINUS  shift, and go to state 51
    DIV    shift, and go to state 52
    MUL    shift, and go to state 53
    MOD    shift, and go to state 54

    $default  reduce using rule 16 (attr)


state 48

   38 final: RETURN INTEGER . SEMICOLON RIGHT_BR

    SEMICOLON  shift, and go to state 58


state 49

   10 lista_isntr: instr SEMICOLON lista_isntr .

    $default  reduce using rule 10 (lista_isntr)


state 50

   23 exp: exp PLUS . const
   28    | exp PLUS . variabila

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    const      go to state 59
    variabila  go to state 60


state 51

   22 exp: exp MINUS . const
   29    | exp MINUS . variabila

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    const      go to state 61
    variabila  go to state 62


state 52

   24 exp: exp DIV . const
   30    | exp DIV . variabila

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    const      go to state 63
    variabila  go to state 64


state 53

   25 exp: exp MUL . const
   32    | exp MUL . variabila

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    const      go to state 65
    variabila  go to state 66


state 54

   31 exp: exp MOD . variabila

    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    variabila  go to state 67


state 55

   37 condition: exp RELATION . exp

    INTEGER   shift, and go to state 39
    FLOAT     shift, and go to state 40
    ID        shift, and go to state 24
    IDVECTOR  shift, and go to state 25

    $default  reduce using rule 21 (exp)

    const      go to state 41
    variabila  go to state 42
    exp        go to state 68


state 56

   35 if_exp: IFSTMT LEFT_PAR condition RIGHT_PAR . LEFT_BR lista_isntr RIGHT_BR

    LEFT_BR  shift, and go to state 69


state 57

   36 while_exp: WHILESTMT LEFT_PAR condition RIGHT_PAR . LEFT_BR lista_isntr RIGHT_BR

    LEFT_BR  shift, and go to state 70


state 58

   38 final: RETURN INTEGER SEMICOLON . RIGHT_BR

    RIGHT_BR  shift, and go to state 71


state 59

   23 exp: exp PLUS const .

    $default  reduce using rule 23 (exp)


state 60

   28 exp: exp PLUS variabila .

    $default  reduce using rule 28 (exp)


state 61

   22 exp: exp MINUS const .

    $default  reduce using rule 22 (exp)


state 62

   29 exp: exp MINUS variabila .

    $default  reduce using rule 29 (exp)


state 63

   24 exp: exp DIV const .

    $default  reduce using rule 24 (exp)


state 64

   30 exp: exp DIV variabila .

    $default  reduce using rule 30 (exp)


state 65

   25 exp: exp MUL const .

    $default  reduce using rule 25 (exp)


state 66

   32 exp: exp MUL variabila .

    $default  reduce using rule 32 (exp)


state 67

   31 exp: exp MOD variabila .

    $default  reduce using rule 31 (exp)


state 68

   22 exp: exp . MINUS const
   23    | exp . PLUS const
   24    | exp . DIV const
   25    | exp . MUL const
   28    | exp . PLUS variabila
   29    | exp . MINUS variabila
   30    | exp . DIV variabila
   31    | exp . MOD variabila
   32    | exp . MUL variabila
   37 condition: exp RELATION exp .

    PLUS   shift, and go to state 50
    MINUS  shift, and go to state 51
    DIV    shift, and go to state 52
    MUL    shift, and go to state 53
    MOD    shift, and go to state 54

    $default  reduce using rule 37 (condition)


state 69

   35 if_exp: IFSTMT LEFT_PAR condition RIGHT_PAR LEFT_BR . lista_isntr RIGHT_BR

    INOP       shift, and go to state 12
    OUTOP      shift, and go to state 13
    IFSTMT     shift, and go to state 14
    WHILESTMT  shift, and go to state 15
    ID         shift, and go to state 16

    SEMICOLON  reduce using rule 11 (instr)
    $default   reduce using rule 9 (lista_isntr)

    lista_isntr  go to state 72
    instr        go to state 18
    attr         go to state 19
    inout        go to state 20
    if_exp       go to state 21
    while_exp    go to state 22


state 70

   36 while_exp: WHILESTMT LEFT_PAR condition RIGHT_PAR LEFT_BR . lista_isntr RIGHT_BR

    INOP       shift, and go to state 12
    OUTOP      shift, and go to state 13
    IFSTMT     shift, and go to state 14
    WHILESTMT  shift, and go to state 15
    ID         shift, and go to state 16

    SEMICOLON  reduce using rule 11 (instr)
    $default   reduce using rule 9 (lista_isntr)

    lista_isntr  go to state 73
    instr        go to state 18
    attr         go to state 19
    inout        go to state 20
    if_exp       go to state 21
    while_exp    go to state 22


state 71

   38 final: RETURN INTEGER SEMICOLON RIGHT_BR .

    $default  reduce using rule 38 (final)


state 72

   35 if_exp: IFSTMT LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr . RIGHT_BR

    RIGHT_BR  shift, and go to state 74


state 73

   36 while_exp: WHILESTMT LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr . RIGHT_BR

    RIGHT_BR  shift, and go to state 75


state 74

   35 if_exp: IFSTMT LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR .

    $default  reduce using rule 35 (if_exp)


state 75

   36 while_exp: WHILESTMT LEFT_PAR condition RIGHT_PAR LEFT_BR lista_isntr RIGHT_BR .

    $default  reduce using rule 36 (while_exp)
